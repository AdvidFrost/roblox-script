local executor = identifyexecutor()
    print(executor)
local Flux = loadstring(game:HttpGet("https://raw.githubusercontent.com/weakhoes/Roblox-UI-Libs/main/Flux%20Lib/Flux%20Lib%20Source.lua"))()

local window = Flux:Window("Realm Rampage", "join discord :)    (" .. executor .. ")", Color3.fromRGB(255, 110, 48), Enum.KeyCode.RightControl)

local PlayerTab = window:Tab("Player", "rbxassetid://18107224538")
local TeleportsTab = window:Tab("Teleports", "rbxassetid://12941020168")
local MiscTab = window:Tab("Misc", "rbxassetid://6034509993")
local EmotesTab = window:Tab("Emotes", "rbxassetid://11932783331")
local AnimationsTab = window:Tab("Animations", "rbxassetid://10709769841")
local DomainTab = window:Tab("Domain", "rbxassetid://87373733603687")
local AutoCounterTab = window:Tab("AutoCounter", "rbxassetid://18226013553") -- Replace with an appropriate icon asset id
local CreditsTab = window:Tab("Credits", "rbxassetid://6026568198")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer

-- Variables for AutoCounter
local scanDelayValue = 1  -- default value in milliseconds
local scanDistanceValue = 7  -- default value for scan radius
local autoCounterEnabled = false
local debugVisualizationEnabled = false

-- AutoCounter Tab
AutoCounterTab:Toggle("Enable Auto Counter", "Toggle to turn Auto Counter on/off", false, function(state)
    autoCounterEnabled = state
    if autoCounterEnabled then
        startScanning()
    else
        _G.scanningLoopRunning = false  -- Stop the scanning loop
    end
end)

AutoCounterTab:Toggle("radius sphere", "show radius sphere (debugging)", false, function(state)
    debugVisualizationEnabled = state
    if debugVisualizationEnabled then
        createScanRadiusVisualization()
    else
        removeScanRadiusVisualization()
    end
end)

AutoCounterTab:Slider("Scan Delay (ms)", "Delay between scans in milliseconds", 1, 300, 1, function(value)
    scanDelayValue = value
end)

AutoCounterTab:Slider("Scan Range", "Range to scan for players", 1, 25, 7, function(value)
    scanDistanceValue = value
    -- Update the scan radius sphere's size, if visualization is enabled
    if debugVisualizationEnabled and scanRadiusSphere then
        scanRadiusSphere.Size = Vector3.new(scanDistanceValue * 2, scanDistanceValue * 2, scanDistanceValue * 2)
    end
end)

-- Variables and functions for AutoCounter script
local targetAccessories = {      -- List of accessory names to detect on other players
    "M1ING",
    "FowardDashing",
    "Cooldown"
}

-- Mapping of Character Attributes to Tool Names
local toolActions = {
    ["MenacingVampire"] = "Dio Counter",
    ["DisgracedOne"]    = "Cleave Dance"
}

local scanRadiusSphere               -- Variable to hold the visualization sphere

-- Utility Function: Debugging Output (Optional)
local function debugPrint(message)
    if debugVisualizationEnabled then
        print("[AutoCounter] " .. message)
    end
end

-- Function to Create scan radius visualization
function createScanRadiusVisualization()
    if not debugVisualizationEnabled then return end

    -- Create a new Part to represent the scan radius
    scanRadiusSphere = Instance.new("Part")
    scanRadiusSphere.Name = "ScanRadiusVisualizer"
    scanRadiusSphere.Shape = Enum.PartType.Ball
    scanRadiusSphere.Material = Enum.Material.Neon
    scanRadiusSphere.Color = Color3.fromRGB(0, 255, 0)  -- Green color for visibility
    scanRadiusSphere.Transparency = 0.7              -- Semi-transparent
    scanRadiusSphere.CanCollide = false
    scanRadiusSphere.Anchored = true
    scanRadiusSphere.Size = Vector3.new(scanDistanceValue * 2, scanDistanceValue * 2, scanDistanceValue * 2)
    scanRadiusSphere.Parent = workspace

    -- Optionally, lock the visualization to the camera or player
end

-- Function to Update scan radius visualization position
local function updateScanRadiusVisualization()
    if not debugVisualizationEnabled or not scanRadiusSphere then return end

    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        scanRadiusSphere.Position = localPlayer.Character.HumanoidRootPart.Position
    end
end

-- Function to Remove scan radius visualization
function removeScanRadiusVisualization()
    if scanRadiusSphere then
        scanRadiusSphere:Destroy()
        scanRadiusSphere = nil
    end
end

-- Function to Equip and Then Unequip a Tool
local function equipAndUnequipTool(toolName)
    if not toolName then
        debugPrint("No tool name provided for equip/unequip action.")
        return
    end

    -- Attempt to find the tool in Backpack or Character
    local tool = localPlayer.Backpack:FindFirstChild(toolName) or
                 (localPlayer.Character and localPlayer.Character:FindFirstChild(toolName))

    if tool then
        local humanoid = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            -- Equip the tool
            humanoid:EquipTool(tool)
            debugPrint("Equipped tool: " .. toolName)

            -- Wait briefly before unequipping
            wait(0.1)

            -- Unequip the tool
            humanoid:UnequipTools()
            debugPrint("Unequipped tool: " .. toolName)
        else
            debugPrint("Humanoid not found in character.")
        end
    else
        debugPrint("Tool '" .. toolName .. "' not found in Backpack or Character.")
    end
end

-- Function to Perform Action Based on Character Attribute
local function performAction(characterAttribute)
    local toolName = toolActions[characterAttribute]
    if toolName then
        equipAndUnequipTool(toolName)
    else
        debugPrint("No action defined for Character attribute: " .. tostring(characterAttribute))
    end
end

-- Function to Scan Nearby Players for Target Accessories
local function scanNearbyPlayers()
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        debugPrint("Local character or HumanoidRootPart not found.")
        return
    end

    local localPosition = localPlayer.Character.HumanoidRootPart.Position

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local otherPosition = player.Character.HumanoidRootPart.Position
            local distance = (localPosition - otherPosition).Magnitude

            if distance <= scanDistanceValue then
                -- Check for any target accessory on the other player's character
                for _, accessoryName in ipairs(targetAccessories) do
                    if player.Character:FindFirstChild(accessoryName) then
                        debugPrint("Detected accessory '" .. accessoryName .. "' on player '" .. player.Name .. "'.")

                        -- Retrieve the local player's "Character" attribute
                        local characterAttribute = localPlayer:GetAttribute("Character") or "Unknown"
                        debugPrint("Local player's Character attribute: " .. tostring(characterAttribute))

                        -- Perform the corresponding action
                        performAction(characterAttribute)

                        -- Exit after handling the first detected accessory
                        return
                    end
                end
            end
        end
    end

    -- Update the visualization's position if enabled
    updateScanRadiusVisualization()
end

-- Function to Start the Scanning Loop
function startScanning()
    -- Prevent multiple scanning loops
    if _G.scanningLoopRunning then
        debugPrint("Scanning loop is already running.")
        return
    end

    _G.scanningLoopRunning = true
    debugPrint("Starting scanning loop.")

    while _G.scanningLoopRunning and autoCounterEnabled and localPlayer.Character and localPlayer.Character.Parent do
        scanNearbyPlayers()
        wait(scanDelayValue / 1000)
    end

    debugPrint("Scanning loop has stopped.")
end

-- Function to Handle Character Spawn
local function onCharacterAdded(character)
    debugPrint("Character spawned. Initializing AutoCounter.")

    -- Ensure HumanoidRootPart is loaded
    character:WaitForChild("HumanoidRootPart")

    -- Create visualization if enabled
    if debugVisualizationEnabled then
        createScanRadiusVisualization()
    end

    -- Start the scanning loop if enabled
    if autoCounterEnabled then
        startScanning()
    end
end

-- Function to Handle Character Removal (e.g., when dying)
local function onCharacterRemoving()
    debugPrint("Character is being removed. Stopping AutoCounter.")
    _G.scanningLoopRunning = false

    -- Remove visualization if enabled
    removeScanRadiusVisualization()
end

-- Initial setup: Connect events and handle existing character
if localPlayer.Character then
    onCharacterAdded(localPlayer.Character)
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)
localPlayer.CharacterRemoving:Connect(onCharacterRemoving)

local function inviteToDiscord()
    local inviteCode = "TyBwFtbhrz"
    if syn and syn.request then
        syn.request({
            Url = "http://127.0.0.1:6463/rpc?v=1",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["Origin"] = "https://discord.com"
            },
            Body = game:GetService("HttpService"):JSONEncode({
                cmd = "INVITE_BROWSER",
                args = {
                    code = inviteCode
                },
                nonce = game:GetService("HttpService"):GenerateGUID(false)
            }),
        })
    elseif http and http.request then
        http.request({
            Url = "http://127.0.0.1:6463/rpc?v=1",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["Origin"] = "https://discord.com"
            },
            Body = game:GetService("HttpService"):JSONEncode({
                cmd = "INVITE_BROWSER",
                args = {
                    code = inviteCode
                },
                nonce = game:GetService("HttpService"):GenerateGUID(false)
            }),
        })
    else
        setclipboard("https://discord.gg/" .. inviteCode)
        Flux:Notification("Discord invite copied to clipboard!", "OK")
    end
end

local respawnCooldown = false
local respawnTimer = 0
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DESTINATION = Vector3.new(-185, 10006, 14811)
local toggleStates = {}

local function handleRespawnCooldown()
    respawnCooldown = true
    respawnTimer = 2  -- 2-second cooldown
    
    spawn(function()
        while respawnTimer > 0 do
            wait(0.1)
            respawnTimer = respawnTimer - 0.1
        end
        respawnCooldown = false
    end)
end

-- Player Tab
PlayerTab:Label("State Toggles")

PlayerTab:Toggle("Fast M1", "Toggle to m1 really fast (best with no freeze)", false, function(state)
    toggleStates.CANTM1 = state
    toggleStates.NoM1Fr = state
end)

PlayerTab:Toggle("Can block", "Makes you able to block while stunned I think", false, function(state)
    toggleStates.NoBlock = state
end)

PlayerTab:Toggle("no foward dash cd", "removes foward dash cd", false, function(state)
    toggleStates.ForwardCD = state
end)

PlayerTab:Toggle("No stun", "Removes freeze/stun", false, function(state)
    toggleStates.Freeze = state
end)

PlayerTab:Toggle("Remove M1ING", "removes M1 state (prolly useless)", false, function(state)
    toggleStates.M1ING = state
end)

PlayerTab:Toggle("Remove cooldown state", "removes cooldown state (useless too)", false, function(state)
    toggleStates.Cooldown = state
end)

PlayerTab:Toggle("always jump", "makes you able to jump whenever", false, function(state)
    toggleStates.NoJump = state
end)

local comboEnabled = false
local comboValue = 1

PlayerTab:Toggle("Enable Combo Loop", "makes ur punch only 1 of 4 types", false, function(state)
    comboEnabled = state
end)

PlayerTab:Dropdown("Combo Value", {"1", "2", "3", "4"}, function(selected)
    comboValue = tonumber(selected)
end)

PlayerTab:Label("Movement Modifiers")

local walkspeedEnabled = false
local walkspeedValue = 16

PlayerTab:Toggle("Enable Walkspeed Modifier", "Toggle to enable custom walkspeed", false, function(state)
    walkspeedEnabled = state
end)

PlayerTab:Slider("Walkspeed Value", "Set custom walkspeed value", 16, 300, 16, function(value)
    walkspeedValue = value
end)

local jumpHeightEnabled = false
local jumpHeightValue = 7.2

PlayerTab:Toggle("Enable Jump Height Modifier", "Toggle to enable custom jump height", false, function(state)
    jumpHeightEnabled = state
end)

PlayerTab:Slider("Jump Height Value", "Set custom jump height value", 7.2, 50, 7.2, function(value)
    jumpHeightValue = value
end)

local function gotopos(x, y, z)
    local player = game.Players.LocalPlayer
    if player.Character then
        player.Character:MoveTo(Vector3.new(x, y, z))
    end
end

TeleportsTab:Button("Weird Area (Laggy)", "Teleports you to somewhere idek", function()
print('test')
    gotopos(-194, 10008, 14811)
end)

TeleportsTab:Button("Red Land", "wth is this", function()
print('test')
    gotopos(-899533, 38, -44)
end)

TeleportsTab:Button("Middle of the Map", "Teleports you to the middle of the map", function()
    gotopos(526, 301, -291)
    print('test')
end)

MiscTab:Label("Infinite Yield Reborn")
MiscTab:Button("Load IY Reborn", "loads iy (great script)", function()
    loadstring(game:HttpGet("https://storage.iyr.lol/legacy-iyr/source"))()
end)

MiscTab:Label("Black Flash Helper")

local blackFlashEnabled = false
local blackFlashDelay = 0.5

MiscTab:Toggle("Enable Black Flash Helper", "normally nails a blackflash for u", false, function(state)
    blackFlashEnabled = state
end)

MiscTab:Slider("Black Flash Delay", "sets delay for blackflash (ms)", 0, 100, 38, function(value)
    blackFlashDelay = value / 100
end)

local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Flag to prevent the script from triggering on its own virtual input
local ignoreNextPress = false

-- Function to simulate key press
local function simulateKeyPress()
    ignoreNextPress = true
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
    wait(0.05) -- Short delay to simulate a key press
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
    ignoreNextPress = false
end

-- Connect the input event
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.R and not gameProcessed and not ignoreNextPress and blackFlashEnabled then
        -- Wait for the specified delay before simulating the key press
        wait(blackFlashDelay)
        simulateKeyPress()
    end
end)

MiscTab:Label("Skill Bring")

local regularBringEnabled = false
local allBringEnabled = false
local selectedLocation = "Default"

MiscTab:Toggle("Regular Bring", "teleports one person with most moves", false, function(state)
    regularBringEnabled = state
    if state then
        loadRegularBringScript()
    end
end)

MiscTab:Toggle("All Bring", "only for sukuna combo and katakuri rn", false, function(state)
    allBringEnabled = state
    if state then
        loadAllBringScript()
    end
end)

MiscTab:Dropdown("Locations", {"void", "skyblock"}, function(selected)
    selectedLocation = selected
    updateBringDestination(selected)
end)

-- Regular Bring Script
function loadRegularBringScript()
    local LocalPlayer = Players.LocalPlayer

    local ANIMATION_IDS = {
        ["17334373908"] = {waitBefore = 1, waitAt = 2},
        ["18132953876"] = {waitBefore = 1.5, waitAt = 1.5},
        ["17147384246"] = {waitBefore = 1.5, waitAt = 1.5},
        ["17173007436"] = {waitBefore = 1.5, waitAt = 1.5},
        ["124252923387937"] = {waitBefore = 0.3, waitAt = 1.5},
        ["94942503786924"] = {waitBefore = 0.5, waitAt = 2},
        ["104531813000057"] = {waitBefore = 0.5, waitAt = 2},
        ["17657186726"] = {waitBefore = 0.5, waitAt = 2},
        ["17647684136"] = {waitBefore = 0.3, waitAt = 2},
        ["18485162457"] = {waitBefore = 0.5, waitAt = 2}
    }

    local isTeleporting = false
    local originalPosition = nil

    local function teleportSequence(waitBefore, waitAt)
        if respawnCooldown or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then 
            print("Teleport sequence canceled: Cooldown active or Character/HumanoidRootPart not found")
            return 
        end
        
        isTeleporting = true
        originalPosition = LocalPlayer.Character.HumanoidRootPart.Position
        
        print("Teleport sequence started. Waiting before teleport:", waitBefore)
        task.wait(waitBefore)
        
        print("Teleporting to destination")
        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(DESTINATION))
        
        print("Waiting at destination:", waitAt)
        task.wait(waitAt)
        
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            print("Returning to original position")
            LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
        else
            print("Failed to return: Character or HumanoidRootPart not found")
        end
        
        isTeleporting = false
        print("Teleport sequence completed")
    end

    local function onAnimationPlayed(animTrack)
        if isTeleporting or not regularBringEnabled or respawnCooldown then return end
        
        local animationId = animTrack.Animation.AnimationId:match("%d+")
        print("Animation played:", animationId)
        
        if ANIMATION_IDS[animationId] then
            print("Matching animation found. Starting teleport sequence")
            teleportSequence(ANIMATION_IDS[animationId].waitBefore, ANIMATION_IDS[animationId].waitAt)
        end
    end

    local function setupAnimationDetection()
        local character = LocalPlayer.Character
        if not character then 
            print("Character not found. Waiting for character...")
            character = LocalPlayer.CharacterAdded:Wait()
            handleRespawnCooldown()  -- Add cooldown when character is added
        end
        
        local humanoid = character:WaitForChild("Humanoid")
        print("Humanoid found. Setting up animation detection")
        
        humanoid.AnimationPlayed:Connect(onAnimationPlayed)
    end

    setupAnimationDetection()
    LocalPlayer.CharacterAdded:Connect(function(char)
        setupAnimationDetection()
        handleRespawnCooldown()  -- Add cooldown when character is added
    end)
end

-- All Bring Script
function loadAllBringScript()
    local LocalPlayer = Players.LocalPlayer

    local ANIMATION_IDS = {
        ["18400938867"] = {
            startDelay = 0,
            teleportDuration = 2,
            endDelay = 0,
            returnDelay = 8
        },
        ["17806727401"] = {
            startDelay = 5,
            teleportDuration = 1.5,
            endDelay = 0,
            returnDelay = 1.5
        }
    }
    local TELEPORT_DELAY = 0.1
    local TELEPORT_DISTANCE = 7

    local isTeleporting = false
    local originalPosition = nil

    local function getTeleportPosition(targetPlayer)
        local targetCharacter = targetPlayer.Character
        if not targetCharacter then return nil end
        
        local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
        if not targetRoot then return nil end
        
        local direction = (targetRoot.Position - LocalPlayer.Character.HumanoidRootPart.Position).Unit
        return targetRoot.Position + direction * TELEPORT_DISTANCE
    end

    local function teleportToPlayers(config)
        if respawnCooldown or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then 
            print("Teleport sequence canceled: Cooldown active or Character/HumanoidRootPart not found")
            return 
        end
        
        originalPosition = LocalPlayer.Character.HumanoidRootPart.Position
        isTeleporting = true
        
        print("Starting teleport sequence. Waiting for start delay:", config.startDelay)
        task.wait(config.startDelay)
        
        local startTime = tick()
        print("Teleporting to players")
        while tick() - startTime < config.teleportDuration do
            local playerList = Players:GetPlayers()
            for _, player in ipairs(playerList) do
                if player ~= LocalPlayer then
                    local teleportPosition = getTeleportPosition(player)
                    if teleportPosition then
                        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(teleportPosition))
                        task.wait(TELEPORT_DELAY)
                    end
                end
            end
        end
        
        print("Finished teleporting to players. Waiting for end delay:", config.endDelay)
        task.wait(config.endDelay)
        
        print("Teleporting to set destination")
        LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(DESTINATION))
        
        print("Waiting for return delay:", config.returnDelay)
        task.wait(config.returnDelay)
        
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            print("Returning to original position")
            LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
        else
            print("Failed to return: Character or HumanoidRootPart not found")
        end
        
        isTeleporting = false
        print("Teleport sequence completed")
    end

    local function onAnimationPlayed(animTrack)
        if isTeleporting or not allBringEnabled or respawnCooldown then return end
        
        local animationId = animTrack.Animation.AnimationId:match("%d+")
        print("Animation played:", animationId)
        
        if ANIMATION_IDS[animationId] then
            print("Matching animation found. Starting teleport sequence")
            teleportToPlayers(ANIMATION_IDS[animationId])
        end
    end

    local function setupAnimationDetection()
        local character = LocalPlayer.Character
        if not character then 
            print("Character not found. Waiting for character...")
            character = LocalPlayer.CharacterAdded:Wait()
            handleRespawnCooldown()  -- Add cooldown when character is added
        end
        
        local humanoid = character:WaitForChild("Humanoid")
        print("Humanoid found. Setting up animation detection")
        
        humanoid.AnimationPlayed:Connect(onAnimationPlayed)
    end

    setupAnimationDetection()
    LocalPlayer.CharacterAdded:Connect(function(char)
        setupAnimationDetection()
        handleRespawnCooldown()  -- Add cooldown when character is added
    end)
end

function updateBringDestination(location)
    if location == "void" then
        DESTINATION = Vector3.new(9999999,9999999999,9999999999)
    elseif location == "skyblock" then
        DESTINATION = Vector3.new(-185, 10006, 14811)
    end
end

MiscTab:Label("placeholder")


local EmoteNames = {}
for _, emote in pairs(game:GetService("ReplicatedStorage").Emotes:GetChildren()) do
    table.insert(EmoteNames, emote.Name)
end

local SelectedEmote = EmoteNames[1]
local LoopEmotes = false

EmotesTab:Dropdown("Select Emote", EmoteNames, function(selected)
    SelectedEmote = selected
end)

EmotesTab:Toggle("Loop Emotes", "Toggle to loop the selected emote", false, function(state)
    LoopEmotes = state
end)

local function PlayEmote()
    local args = {
        [1] = {
            ["Name"] = SelectedEmote,
            ["Type"] = "PlayEmote"
        }
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Replicate"):FireServer(unpack(args))
end

local function WaitForEmoteToFinish()
    local character = game.Players.LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.AnimationPlayed:Wait()
        end
    end
end

EmotesTab:Button("Play Emote", "Click to play the selected emote", function()
    if LoopEmotes then
        spawn(function()
            while LoopEmotes do
                PlayEmote()
                WaitForEmoteToFinish()
                wait(0.1) -- Small delay to prevent potential issues
            end
        end)
    else
        PlayEmote()
    end
end)

EmotesTab:Label("Other Features")

EmotesTab:Button("Give All Emotes", "Click to get all emotes, emotes in your wheel stay after leaving!", function()
    local allEmotes = {}
    for _, emote in pairs(game:GetService("ReplicatedStorage").Emotes:GetChildren()) do
        table.insert(allEmotes, emote.Name)
    end
    
    local formattedEmotes = '["' .. table.concat(allEmotes, '","') .. '"]'
    local player = game.Players.LocalPlayer
    
    if player then
        player:SetAttribute("OwnedEmotes", formattedEmotes)
        Flux:Notification("All emotes added to locker!", "OK")
    else
        Flux:Notification("Failed to add emotes. Player not found.", "OK")
    end
end)

AnimationsTab:Label("Idle Animations")

local idleAnimationEnabled = false
local selectedIdleAnimation = "Cool Stance"
local idleAnimations = {
    ["Cool Stance"] = {
        id = 17418658417,
        loopStart = 0.0,    -- Start time in seconds
        loopEnd = 2.0,      -- End time in seconds
        forwardSpeed = 1,
        reverseSpeed = -1
    },
    ["Menacing"] = {
        id = 17484770831,
        loopStart = 0.7,
        loopEnd = 0.8,
        forwardSpeed = 0.2,
        reverseSpeed = -0.2
    },
    ["Majestic"] = {
        id = 17798742655,
        loopStart = 0.2,
        loopEnd = 0.4,
        forwardSpeed = 0.4,
        reverseSpeed = -0.4
    },
    ["Dio"] = {
        id = 18455969319,
        loopStart = 0.3,
        loopEnd = 0.55,
        forwardSpeed = 0.4,
        reverseSpeed = -0.4
    },
    ["MAHORAGA!!!!"] = {
        id = 17228130181,
        loopStart = 1,
        loopEnd = 1.3,
        forwardSpeed = 0.4,
        reverseSpeed = -0.4
    },
    ["Honored"] = {
        id = 17118074381,
        loopStart = 1,
        loopEnd = 1.2,
        forwardSpeed = 0.6,
        reverseSpeed = -0.6
    },
    ["Flight"] = {
        id = 18417381632,
        loopStart = 0.0,
        loopEnd = 2.0,
        forwardSpeed = 1,
        reverseSpeed = -1
    }
}


local customIdleAnimTrack = nil
local idleIsAnimating = false
local idleIsReversing = false
local humanoidConnection = nil
local heartbeatConnection = nil
local animator = nil  -- Moved outside functions for access

-- Function to play the custom idle animation track
local function playCustomIdleAnimationTrack()
    -- Ensure the latest selectedAnimation
    local selectedAnimation = idleAnimations[selectedIdleAnimation]
    if not selectedAnimation then
        warn("Selected animation not found.")
        return
    end

    -- Create and load the animation
    local animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://" .. selectedAnimation.id
    customIdleAnimTrack = animator:LoadAnimation(animation)

    customIdleAnimTrack.Priority = Enum.AnimationPriority.Idle

    -- We handle the looping ourselves
    customIdleAnimTrack.Looped = false

    -- Set initial TimePosition and speed
    customIdleAnimTrack.TimePosition = selectedAnimation.loopStart
    customIdleAnimTrack:AdjustSpeed(selectedAnimation.forwardSpeed)

    -- Start the animation
    customIdleAnimTrack:Play()

    idleIsAnimating = true
    idleIsReversing = false

    -- Connect to Heartbeat to monitor and manage ping-pong
    heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
        if not customIdleAnimTrack or not customIdleAnimTrack.IsPlaying then
            return
        end

        local currentTime = customIdleAnimTrack.TimePosition

        if not idleIsReversing then
            if currentTime >= selectedAnimation.loopEnd then
                idleIsReversing = true
                customIdleAnimTrack:AdjustSpeed(selectedAnimation.reverseSpeed)
                print("Idle Animation: Switching to reverse. Current Time:", currentTime)
            end
        else
            if currentTime <= selectedAnimation.loopStart then
                idleIsReversing = false
                customIdleAnimTrack:AdjustSpeed(selectedAnimation.forwardSpeed)
                print("Idle Animation: Switching to forward. Current Time:", currentTime)
            end
        end
    end)

    -- Disconnect the Heartbeat when animation stops
    customIdleAnimTrack.Stopped:Connect(function()
        print("Custom idle animation stopped.")
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
            heartbeatConnection = nil
        end
        idleIsAnimating = false
    end)
end

local function startCustomIdleAnimation()
    -- Stop any existing custom idle animation
    if customIdleAnimTrack then
        print("Stopping existing custom idle animation.")
        customIdleAnimTrack:Stop()
        customIdleAnimTrack = nil
    end

    -- Disconnect any existing connections
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    if humanoidConnection then
        humanoidConnection:Disconnect()
        humanoidConnection = nil
    end

    idleIsAnimating = true
    idleIsReversing = false

    local player = game.Players.LocalPlayer
    local character = player.Character

    if not character then
        warn("Character not found.")
        return
    end

    -- Wait for the humanoid to exist
    local humanoid = character:WaitForChild("Humanoid")
    if not humanoid then
        warn("Humanoid not found in character.")
        return
    end

    -- Ensure we have a valid animator
    animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end

    -- Connect to Humanoid.Running to manage animation according to movement
    humanoidConnection = humanoid.Running:Connect(function(speed)
        if speed > 0 then
            -- Character is moving, stop the custom idle animation
            if customIdleAnimTrack and customIdleAnimTrack.IsPlaying then
                customIdleAnimTrack:Stop()
                customIdleAnimTrack = nil
            end
            -- Disconnect the Heartbeat when animation stops
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
        else
            -- Character is idle
            if not customIdleAnimTrack or not customIdleAnimTrack.IsPlaying then
                -- Recreate and play the custom idle animation
                playCustomIdleAnimationTrack()
            end
        end
    end)

    -- Start the animation if the character is currently idle
    if humanoid.MoveDirection.Magnitude == 0 then
        playCustomIdleAnimationTrack()
    end
end

-- Function to stop the custom idle animation
local function stopCustomIdleAnimation()
    if customIdleAnimTrack then
        customIdleAnimTrack:Stop()
        customIdleAnimTrack:Destroy()
        customIdleAnimTrack = nil
    end
    if humanoidConnection then
        humanoidConnection:Disconnect()
        humanoidConnection = nil
    end
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    idleIsAnimating = false
    idleIsReversing = false
    print("Custom idle animation stopped.")
end

AnimationsTab:Toggle("Enable Custom Idle Animation", "Toggle to play a custom idle animation", false, function(state)
    idleAnimationEnabled = state
    if idleAnimationEnabled then
        -- Stop any custom animation if it's playing
        if currentAnimTrack then
            print("Stopping custom animation to enable idle animation.")
            currentAnimTrack:Stop()
            currentAnimTrack = nil
            isAnimating = false
        end

        -- Start the custom idle animation
        startCustomIdleAnimation()
    else
        -- Stop the custom idle animation
        stopCustomIdleAnimation()
    end
end)

game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    -- Wait for the humanoid to be added to the character
    local humanoid = character:WaitForChild("Humanoid")

    if idleAnimationEnabled then
        print("Character added. Restarting custom idle animation.")
        startCustomIdleAnimation()
    end
end)

game.Players.LocalPlayer.CharacterRemoving:Connect(function(character)
    -- Stop animations and disconnect events
    if customIdleAnimTrack then
        customIdleAnimTrack:Stop()
        customIdleAnimTrack = nil
    end
    if humanoidConnection then
        humanoidConnection:Disconnect()
        humanoidConnection = nil
    end
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
end)

-- Dropdown to select the idle animation
local animationNames = {}
for name, _ in pairs(idleAnimations) do
    table.insert(animationNames, name)
end

AnimationsTab:Dropdown("Select Animation", animationNames, function(selected)
    selectedIdleAnimation = selected
    if idleAnimationEnabled then
        -- Restart the custom idle animation with the new animation
        startCustomIdleAnimation()
    end
end)

DomainTab:Label("Domain Clash Helper")

local domainClashEnabled = false

DomainTab:Toggle("Enable Domain Clash Helper", "Toggle to always win domain clashes", false, function(state)
    domainClashEnabled = state
    if state then
        loadDomainClashHelper()
    end
end)

-- Function to load Domain Clash Helper
function loadDomainClashHelper()
    local player = game.Players.LocalPlayer
    local UIS = game:GetService("UserInputService")
    local lastMovementTime = 0

    local function sendNotification(message)
        game.StarterGui:SetCore("SendNotification", {
            Title = "Spacebar Spam";
            Text = message;
            Duration = 2;
        })
    end

    sendNotification("Domain Clash Helper Activated")

    local keyFrame = player:WaitForChild("PlayerGui"):WaitForChild("MainUI")
                          :WaitForChild("Domain"):WaitForChild("Clashing")
                          :WaitForChild("Key")

    local lastPosition = keyFrame.AbsolutePosition

    local function spamSpacebar()
        local endTime = tick() + 3
        while tick() < endTime and domainClashEnabled do
            game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Space, false, game)
            wait(0.2)
        end
        game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.Space, false, game)
    end

    game:GetService("RunService").RenderStepped:Connect(function()
        if not domainClashEnabled then return end
        local currentTime = tick()
        local currentPosition = keyFrame.AbsolutePosition

        if currentPosition ~= lastPosition and (currentTime - lastMovementTime) > 30 then
            spamSpacebar()
            lastMovementTime = currentTime
        end

        lastPosition = currentPosition
    end)
end

DomainTab:Label("Anti-Domain")

local antiTimestopEnabled = false

DomainTab:Toggle("Anti-Timestop", "move in timestop and stuff like that", false, function(state)
    antiTimestopEnabled = state
end)

-- Function to continuously remove InTimestop state
local function removeInTimestop()
    while antiTimestopEnabled do
        if game.Players.LocalPlayer.Character then
            game.Players.LocalPlayer.Character:SetAttribute("InTimestop", false)
        end
        wait(0.01)
    end
end

-- Start the anti-timestop loop when enabled
spawn(function()
    while wait(0.01) do
        if antiTimestopEnabled then
            removeInTimestop()
        end
    end
end)

-- Credits Tab
CreditsTab:Label("Script created by advidfrost")

CreditsTab:Button("Join the Discord", "Click to join our Discord server", function()
    local inviteCode = "TyBwFtbhrz"
    if syn and syn.request then
        syn.request({
            Url = "http://127.0.0.1:6463/rpc?v=1",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["Origin"] = "https://discord.com"
            },
            Body = game:GetService("HttpService"):JSONEncode({
                cmd = "INVITE_BROWSER",
                args = {
                    code = inviteCode
                },
                nonce = game:GetService("HttpService"):GenerateGUID(false)
            }),
        })
    elseif http and http.request then
        http.request({
            Url = "http://127.0.0.1:6463/rpc?v=1",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["Origin"] = "https://discord.com"
            },
            Body = game:GetService("HttpService"):JSONEncode({
                cmd = "INVITE_BROWSER",
                args = {
                    code = inviteCode
                },
                nonce = game:GetService("HttpService"):GenerateGUID(false)
            }),
        })
    else
        setclipboard("https://discord.gg/" .. inviteCode)
        Flux:Notification("Discord invite copied to clipboard!", "OK")
    end
end)


local function updateCharacter()
    local player = game.Players.LocalPlayer
    if player.Character then
        for _, accessory in pairs(player.Character:GetChildren()) do
            if accessory:IsA("Accessory") and toggleStates[accessory.Name] then
                accessory:Destroy()
            end
        end
        if comboEnabled then
            player.Character:SetAttribute("Combo", comboValue)
        end
        if walkspeedEnabled and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = walkspeedValue
        end
        if jumpHeightEnabled and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.JumpHeight = jumpHeightValue
        end
    end
end

local function inviteToDiscord()
    local inviteCode = "TyBwFtbhrz"
    if syn and syn.request then
        syn.request({
            Url = "http://127.0.0.1:6463/rpc?v=1",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["Origin"] = "https://discord.com"
            },
            Body = game:GetService("HttpService"):JSONEncode({
                cmd = "INVITE_BROWSER",
                args = {
                    code = inviteCode
                },
                nonce = game:GetService("HttpService"):GenerateGUID(false)
            }),
        })
    elseif http and http.request then
        http.request({
            Url = "http://127.0.0.1:6463/rpc?v=1",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["Origin"] = "https://discord.com"
            },
            Body = game:GetService("HttpService"):JSONEncode({
                cmd = "INVITE_BROWSER",
                args = {
                    code = inviteCode
                },
                nonce = game:GetService("HttpService"):GenerateGUID(false)
            }),
        })
    else
        setclipboard("https://discord.gg/" .. inviteCode)
        Flux:Notification("Discord invite copied to clipboard!", "OK")
    end
end

local function onScriptLoaded()
    local executor = identifyexecutor()
    
    if executor ~= "Solara" then
        Flux:Notification("join discord pls", "wow okay")
        inviteToDiscord()
    else
        Flux:Notification("script loaded", "nice")
    end
end


spawn(function()
    while wait(0.01) do
        updateCharacter()
    end
end)

onScriptLoaded()
